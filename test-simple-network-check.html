<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€åŒ–ç½‘ç»œæ£€æµ‹åŠŸèƒ½æµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            white-space: pre-wrap;
        }
        .result.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .result.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .result.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .result.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px 0;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-available { background: #28a745; }
        .status-unreachable { background: #dc3545; }
        .status-unknown { background: #6c757d; }
        .status-checking { background: #007bff; animation: pulse 1s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ ç®€åŒ–ç½‘ç»œæ£€æµ‹åŠŸèƒ½æµ‹è¯•</h1>
        <p>æµ‹è¯•æ–°çš„ç®€åŒ–ç½‘ç»œæ£€æµ‹é€»è¾‘ï¼ŒéªŒè¯ä¸‰ç§çŠ¶æ€ï¼šå¯ç”¨ã€ä¸å¯è¾¾ã€æœªçŸ¥</p>

        <div class="test-section">
            <h3>ğŸ¯ æµ‹è¯•é…ç½®</h3>
            <label>æµ‹è¯•URL:</label>
            <input type="text" id="test-url" placeholder="è¾“å…¥è¦æµ‹è¯•çš„URL" value="https://www.google.com">
            <button onclick="testSingleUrl()">æµ‹è¯•å•ä¸ªURL</button>
            <button onclick="testMultipleUrls()">æµ‹è¯•å¤šä¸ªURL</button>
            <button onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
        </div>

        <div class="test-section">
            <h3>ğŸ“Š æ£€æµ‹ç»“æœ</h3>
            <div id="results"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“ˆ æ‰¹é‡æµ‹è¯•ç»“æœ</h3>
            <div id="batch-results"></div>
        </div>
    </div>

    <script type="module">
        // ç®€åŒ–çš„ç½‘ç»œæ£€æµ‹é€»è¾‘ï¼ˆå¤åˆ¶è‡ªé¡¹ç›®ä»£ç ï¼‰
        const SIMPLE_CHECK_CONFIG = {
            timeout: 5000,
            concurrency: 4,
            methods: ['HEAD', 'GET'],
            retryCount: 1,
            cacheEnabled: true
        };

        const statusCache = new Map();
        const CACHE_DURATION = 30000;

        const getCachedResult = (url) => {
            if (!SIMPLE_CHECK_CONFIG.cacheEnabled) return null;
            const cached = statusCache.get(url);
            if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
                return cached.result;
            }
            return null;
        };

        const setCachedResult = (url, result) => {
            if (!SIMPLE_CHECK_CONFIG.cacheEnabled) return;
            statusCache.set(url, {
                result,
                timestamp: Date.now()
            });
        };

        const basicNetworkCheck = async (url, timeout = SIMPLE_CHECK_CONFIG.timeout) => {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, {
                    method: 'HEAD',
                    signal: controller.signal,
                    cache: 'no-cache',
                    credentials: 'omit',
                    headers: {
                        'Accept': '*/*',
                        'User-Agent': 'Environment-Monitor/1.0'
                    }
                });

                clearTimeout(timeoutId);
                
                if (response.status >= 200 && response.status < 400) {
                    return { success: true, status: response.status, method: 'head' };
                }
                
                if (response.status >= 400) {
                    return { success: true, status: response.status, method: 'head' };
                }

                return { success: false, error: `HTTP ${response.status}`, method: 'head' };

            } catch (error) {
                clearTimeout(timeoutId);
                
                if (error.name !== 'AbortError') {
                    try {
                        const getController = new AbortController();
                        const getTimeoutId = setTimeout(() => getController.abort(), timeout);

                        const getResponse = await fetch(url, {
                            method: 'GET',
                            signal: getController.signal,
                            cache: 'no-cache',
                            credentials: 'omit',
                            headers: {
                                'Accept': '*/*',
                                'User-Agent': 'Environment-Monitor/1.0'
                            }
                        });

                        clearTimeout(getTimeoutId);
                        
                        if (getResponse.status >= 200 && getResponse.status < 600) {
                            return { success: true, status: getResponse.status, method: 'get' };
                        }

                    } catch (getError) {
                        // GETä¹Ÿå¤±è´¥äº†ï¼Œç»§ç»­å¤„ç†åŸå§‹é”™è¯¯
                    }
                }

                if (error.name === 'AbortError') {
                    return { success: false, error: 'timeout', method: 'timeout' };
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯CORSç›¸å…³é”™è¯¯
                if (error.name === 'TypeError') {
                    const corsErrorPatterns = [
                        'Failed to fetch',
                        'Load failed',
                        'Network request failed',
                        'CORS',
                        'cross-origin',
                        'Access-Control',
                        'blocked by CORS policy'
                    ];

                    const isCorsError = corsErrorPatterns.some(pattern =>
                        error.message.toLowerCase().includes(pattern.toLowerCase())
                    );

                    if (isCorsError) {
                        return { success: false, error: 'cors_error', method: 'cors_error' };
                    } else {
                        return { success: false, error: 'network_error', method: 'network_error' };
                    }
                }

                return { success: false, error: error.message, method: 'error' };
            }
        };

        const fallbackConnectivityCheck = async (url, timeout = SIMPLE_CHECK_CONFIG.timeout) => {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                await fetch(url, {
                    method: 'GET',
                    mode: 'no-cors',
                    signal: controller.signal,
                    cache: 'no-cache',
                    credentials: 'omit'
                });

                clearTimeout(timeoutId);
                return { success: true, method: 'no-cors' };

            } catch (error) {
                clearTimeout(timeoutId);
                
                if (error.name === 'AbortError') {
                    return { success: false, error: 'timeout', method: 'no-cors-timeout' };
                }
                
                return { success: false, error: error.message, method: 'no-cors-error' };
            }
        };

        const checkEnvironmentStatus = async (environment) => {
            const startTime = Date.now();
            
            const cached = getCachedResult(environment.url);
            if (cached) {
                return cached;
            }

            try {
                const basicResult = await basicNetworkCheck(environment.url);
                
                if (basicResult.success) {
                    const result = {
                        id: environment.id,
                        status: 'available',
                        responseTime: Date.now() - startTime,
                        lastChecked: new Date().toISOString(),
                        error: null,
                        method: basicResult.method,
                        statusCode: basicResult.status
                    };
                    
                    setCachedResult(environment.url, result);
                    return result;
                }

                if (basicResult.error === 'cors_error' || basicResult.error === 'network_error') {
                    const fallbackResult = await fallbackConnectivityCheck(environment.url);

                    if (fallbackResult.success) {
                        const result = {
                            id: environment.id,
                            status: 'available',
                            responseTime: Date.now() - startTime,
                            lastChecked: new Date().toISOString(),
                            error: basicResult.error === 'cors_error' ? 'CORSé™åˆ¶ä½†æœåŠ¡å¯è¾¾' : 'ç½‘ç»œé™åˆ¶ä½†æœåŠ¡å¯è¾¾',
                            method: fallbackResult.method,
                            statusCode: null
                        };

                        setCachedResult(environment.url, result);
                        return result;
                    }
                }

                const result = {
                    id: environment.id,
                    status: basicResult.error === 'timeout' ? 'unknown' : 'unreachable',
                    responseTime: Date.now() - startTime,
                    lastChecked: new Date().toISOString(),
                    error: basicResult.error,
                    method: basicResult.method,
                    statusCode: null
                };
                
                setCachedResult(environment.url, result);
                return result;

            } catch (error) {
                const result = {
                    id: environment.id,
                    status: 'unknown',
                    responseTime: Date.now() - startTime,
                    lastChecked: new Date().toISOString(),
                    error: `æ£€æµ‹å¼‚å¸¸: ${error.message}`,
                    method: 'exception',
                    statusCode: null
                };
                
                setCachedResult(environment.url, result);
                return result;
            }
        };

        // æµ‹è¯•å‡½æ•°
        window.testSingleUrl = async function() {
            const url = document.getElementById('test-url').value;
            if (!url) {
                alert('è¯·è¾“å…¥æµ‹è¯•URL');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="result info">æ­£åœ¨æ£€æµ‹...</div>';

            const environment = { id: 'test', url: url, name: 'Test Service' };
            
            try {
                const result = await checkEnvironmentStatus(environment);
                
                let statusClass = 'info';
                let statusIndicator = 'status-unknown';
                
                switch (result.status) {
                    case 'available':
                        statusClass = 'success';
                        statusIndicator = 'status-available';
                        break;
                    case 'unreachable':
                        statusClass = 'error';
                        statusIndicator = 'status-unreachable';
                        break;
                    case 'unknown':
                        statusClass = 'warning';
                        statusIndicator = 'status-unknown';
                        break;
                }

                resultsDiv.innerHTML = `
                    <div class="result ${statusClass}">
                        <span class="status-indicator ${statusIndicator}"></span>
                        <strong>æ£€æµ‹ç»“æœ:</strong> ${result.status}
                        <br><strong>URL:</strong> ${url}
                        <br><strong>å“åº”æ—¶é—´:</strong> ${result.responseTime}ms
                        <br><strong>æ£€æµ‹æ–¹æ³•:</strong> ${result.method}
                        <br><strong>çŠ¶æ€ç :</strong> ${result.statusCode || 'N/A'}
                        <br><strong>é”™è¯¯ä¿¡æ¯:</strong> ${result.error || 'æ— '}
                        <br><strong>æ£€æµ‹æ—¶é—´:</strong> ${new Date(result.lastChecked).toLocaleString()}
                    </div>
                `;
            } catch (error) {
                resultsDiv.innerHTML = `<div class="result error">æ£€æµ‹å¤±è´¥: ${error.message}</div>`;
            }
        };

        window.testMultipleUrls = async function() {
            const testUrls = [
                'https://www.google.com',           // åº”è¯¥æ˜¯ available (CORSä½†å¯è¾¾)
                'https://www.github.com',           // åº”è¯¥æ˜¯ available (CORSä½†å¯è¾¾)
                'https://httpbin.org/status/200',   // åº”è¯¥æ˜¯ available (æ­£å¸¸å“åº”)
                'https://httpbin.org/status/404',   // åº”è¯¥æ˜¯ available (4xxä¹Ÿè¡¨ç¤ºå¯è¾¾)
                'https://httpbin.org/status/500',   // åº”è¯¥æ˜¯ available (5xxä¹Ÿè¡¨ç¤ºå¯è¾¾)
                'https://httpbin.org/delay/10',     // åº”è¯¥æ˜¯ unknown (è¶…æ—¶)
                'https://nonexistent-domain-12345.com', // åº”è¯¥æ˜¯ unreachable (DNSå¤±è´¥)
                'https://www.baidu.com',            // åº”è¯¥æ˜¯ available (CORSä½†å¯è¾¾)
                'https://api.github.com',           // åº”è¯¥æ˜¯ available (APIé€šå¸¸å…è®¸CORS)
            ];

            const batchResultsDiv = document.getElementById('batch-results');
            batchResultsDiv.innerHTML = '<div class="result info">æ­£åœ¨æ‰¹é‡æ£€æµ‹...</div>';

            const environments = testUrls.map((url, index) => ({
                id: `test-${index}`,
                url: url,
                name: `Test Service ${index + 1}`
            }));

            const results = [];
            for (const env of environments) {
                try {
                    const result = await checkEnvironmentStatus(env);
                    results.push(result);
                } catch (error) {
                    results.push({
                        id: env.id,
                        status: 'unknown',
                        error: error.message,
                        url: env.url
                    });
                }
            }

            let html = '<h4>æ‰¹é‡æ£€æµ‹ç»“æœ:</h4>';
            results.forEach((result, index) => {
                let statusClass = 'info';
                let statusIndicator = 'status-unknown';
                
                switch (result.status) {
                    case 'available':
                        statusClass = 'success';
                        statusIndicator = 'status-available';
                        break;
                    case 'unreachable':
                        statusClass = 'error';
                        statusIndicator = 'status-unreachable';
                        break;
                    case 'unknown':
                        statusClass = 'warning';
                        statusIndicator = 'status-unknown';
                        break;
                }

                html += `
                    <div class="result ${statusClass}">
                        <span class="status-indicator ${statusIndicator}"></span>
                        <strong>${testUrls[index]}</strong> - ${result.status}
                        (${result.responseTime || 0}ms, ${result.method || 'N/A'})
                        ${result.error ? `<br>é”™è¯¯: ${result.error}` : ''}
                    </div>
                `;
            });

            batchResultsDiv.innerHTML = html;
        };

        window.clearResults = function() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('batch-results').innerHTML = '';
            statusCache.clear();
        };
    </script>
</body>
</html>

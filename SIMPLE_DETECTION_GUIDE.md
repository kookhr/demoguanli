# 🎯 精确HTTP状态检测方案

## 📋 方案概述

基于您对准确性的要求，我们提供了一个**精确获取HTTP状态码**的检测方案：

### 🎯 核心特点
- ✅ **精确状态检测**：优先获取真实HTTP状态码（200, 404, 500等）
- ✅ **准确分类错误**：区分客户端错误(4xx)和服务器错误(5xx)
- ✅ **防止误报**：HTTP 500错误不会显示为"可达"
- ✅ **多层策略**：标准CORS → JSONP → 图片探测 → 连通性检测
- ✅ **纯前端方案**：无需额外服务器，保持轻量级

## 🔧 检测策略（按优先级）

### 策略1：标准CORS请求（优先）
```javascript
// 尝试HEAD和GET请求获取真实状态码
const response = await fetch(url, {
  method: 'HEAD', // 或 'GET'
  cache: 'no-cache',
  credentials: 'omit'
});
// 可以获取 response.status 和 response.statusText
```

**优点**：
- ✅ 获取真实HTTP状态码（200, 404, 500等）
- ✅ 准确区分成功、客户端错误、服务器错误
- ✅ 获取完整响应信息

**适用场景**：
- 正确配置CORS的服务
- 同源请求
- 支持跨域的API

### 策略2：JSONP探测
```javascript
// 对可能支持JSONP的API尝试callback参数
const response = await fetch(`${url}?callback=test&_t=${Date.now()}`);
```

**优点**：
- ✅ 某些API支持JSONP，可获取状态码
- ✅ 绕过部分CORS限制

**适用场景**：
- API路径包含'api'的服务
- 支持JSONP的接口

### 策略3：图片探测
```javascript
// 尝试加载静态资源
const img = new Image();
img.src = `${baseUrl}/favicon.ico?_t=${Date.now()}`;
```

**优点**：
- ✅ 不受CORS限制
- ✅ 可以检测静态资源服务

**限制**：
- ❌ 无法获取确切状态码
- ❌ 依赖静态资源存在

### 策略4：连通性检测（最后备用）
```javascript
// no-cors模式基本连通性检测
await fetch(url, { mode: 'no-cors' });
```

**优点**：
- ✅ 完全绕过CORS限制
- ✅ 基本连通性检测

**限制**：
- ❌ 无法获取状态码
- ❌ 无法区分HTTP错误

## 🎨 精确状态分类

### 状态类型
| 状态 | 显示 | HTTP状态码 | 说明 |
|------|------|-----------|------|
| `online` | 🟢 在线 | 200-299, 300-399 | 服务正常运行 |
| `client-error` | 🟠 客户端错误 | 400-499 | 请求错误，检查URL或参数 |
| `server-error` | 🔴 服务器错误 | 500-599 | 服务器内部错误 |
| `timeout` | ⏰ 超时 | - | 请求超时 |
| `offline` | ⚫ 离线 | - | 网络不可达 |
| `reachable-unverified` | 🔵 可达(未验证) | - | 服务器响应但无法确认状态码 |
| `cors-blocked` | 🟡 CORS受限 | - | CORS阻止但服务可能正常 |
| `unknown-status` | 🟣 状态未知 | 其他 | 收到未知状态码 |

### 检测方式标识
- `standard-head`：HEAD请求成功
- `standard-get`：GET请求成功
- `jsonp-probe`：JSONP探测成功
- `image-probe`：图片探测成功
- `connectivity-check`：连通性检测成功

## 🚀 使用方法

### 1. 检测模式切换
在环境管理页面的状态监控面板中：
- **简化模式**（推荐）：使用 no-cors + 图片探测
- **标准模式**：使用原有的复杂检测策略

### 2. 单个环境检测
- 点击环境卡片上的刷新按钮
- 或右键菜单选择"检测状态"

### 3. 批量检测
- 点击"检测所有"按钮
- 系统会并发检测所有环境（限制并发数为 2）

## 📊 技术实现

### 检测流程
```
开始检测
    ↓
尝试 no-cors 模式
    ↓
成功？ → 返回"可达"
    ↓ 否
尝试图片探测
    ↓
成功？ → 返回"可达"
    ↓ 否
返回"离线"
```

### 超时控制
- **单次检测超时**：8 秒
- **图片探测超时**：5 秒
- **批量检测并发**：2 个环境同时检测

### 错误处理
- **网络错误**：标记为离线
- **超时错误**：标记为离线
- **其他异常**：标记为错误状态

## 🎯 适用场景

### ✅ 适合的场景
- 内网环境监控
- 服务基本可用性检查
- 快速连通性验证
- 轻量级部署需求

### ⚠️ 限制场景
- 需要精确 HTTP 状态码的场景
- 需要响应内容分析的场景
- 需要详细错误信息的场景

## 🔧 配置选项

### 检测配置
```javascript
const config = {
  timeout: 8000,           // 检测超时时间
  retry: {
    maxAttempts: 1,        // 重试次数
    delay: 500             // 重试延迟
  },
  imagePaths: [            // 图片探测路径
    '/favicon.ico',
    '/favicon.png',
    '/apple-touch-icon.png'
  ]
};
```

### 自定义配置
配置会自动保存到浏览器本地存储，支持：
- 调整超时时间
- 修改图片探测路径
- 设置重试策略

## 🚀 性能优化

### 1. 并发控制
- 限制同时检测的环境数量
- 避免浏览器连接数限制

### 2. 缓存策略
- 使用 `cache: 'no-cache'` 避免缓存干扰
- 图片 URL 添加时间戳防止缓存

### 3. 超时优化
- 合理设置超时时间
- 快速失败，避免长时间等待

## 🔍 故障排除

### 1. 检测失败
**现象**：所有环境都显示离线
**解决**：
- 检查网络连接
- 确认服务是否真的在运行
- 尝试手动访问服务 URL

### 2. Mixed Content 问题
**现象**：HTTPS 页面无法检测 HTTP 服务
**解决**：
- 简化模式会自动处理此问题
- no-cors 模式不受 Mixed Content 限制

### 3. 检测速度慢
**现象**：检测时间过长
**解决**：
- 减少超时时间设置
- 检查网络延迟
- 确认服务响应速度

## 📈 与复杂方案对比

| 特性 | 简化方案 | 复杂方案 |
|------|----------|----------|
| 部署复杂度 | ✅ 极简 | ❌ 需要代理服务器 |
| 获取状态码 | ❌ 不支持 | ✅ 支持 |
| CORS 绕过 | ✅ 完全绕过 | ✅ 完全绕过 |
| Mixed Content | ✅ 自动处理 | ✅ 自动处理 |
| 维护成本 | ✅ 极低 | ❌ 需要维护服务器 |
| 检测准确性 | ⚠️ 基本准确 | ✅ 高精度 |
| 响应速度 | ✅ 快速 | ⚠️ 依赖代理延迟 |

## 💡 最佳实践

### 1. 使用建议
- 优先使用简化模式
- 定期检查而非实时监控
- 关注趋势而非瞬时状态

### 2. 配置建议
- 内网服务：超时 5-8 秒
- 外网服务：超时 8-10 秒
- 批量检测：并发数 2-3

### 3. 监控建议
- 结合状态历史分析趋势
- 关注持续离线的服务
- 定期验证检测结果

---

**总结**：简化方案专注于核心需求，提供轻量级、可靠的网络连通性检测。虽然无法获取详细的 HTTP 状态信息，但完全满足基本的服务可用性监控需求，且部署和维护成本极低。
